\chapter{Related Work}
\label{chap:related}

In this chapter we are going to present the mechanics of some kind of fuzzers
and some specific implementations of \acfp{CGF}. Then we move on presenting
efforts of researchers trying to combine different fuzzing engines or testing
techniques with the aim of improving performance or efficiency.

\section{Black-box Mutational Fuzzing}
\label{sec:bbfuzz}
Black-box \emph{mutational} fuzzing (or \emph{Random Testing}) is a simple
testing technique that uses mutation operators on a sample input to produce a
new input; a corpus of \emph{valid} files (the more the better) is required to
achieve good efficiency by reducing the search space. A simple algorithmic
representation is given in Algorithm~\ref{algo:bbfuzzing}.

\begin{algorithm}
    \DontPrintSemicolon%
    \SetKwFunction{SelectSeed}{SelectSeed}
    \SetKwFunction{MutateSeed}{MutateSeed}
    \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
    \Input{Set of samples $S$}
    \Output{Set of crashing inputs $C$}
    \BlankLine%
    $C \leftarrow \emptyset$\;
    \While{stop condition is not met}{%
        $t \leftarrow \SelectSeed{S}$\;\nllabel{algo:bbfuzzing:ss}
        $t^\prime \leftarrow \MutateSeed{t}$\;\nllabel{algo:bbfuzzing:ms}
        \If{$t^\prime$ crashes program}{%
            $C \leftarrow C \bigcup \{t^\prime\}$\;
        }
    }
    \caption{Black-box mutational fuzzing}
\label{algo:bbfuzzing}
\end{algorithm}

The main algorithm works within a loop that stops at a predetermined condition
such as the end of a time budget, after the first crash has been found or after
a certain number of inputs have been tested, to name a few. More rudimentary
tools such as \textbf{zzuf}~\cite{hocevar2011zzuf} or
\textbf{Radamsa}~\cite{helin2015radamsa} allow for the tester to apply his or
her own stop criteria for the fuzzing campaign. The \texttt{SelectSeed} function
on line~\ref{algo:bbfuzzing:ss} of Algorithm~\ref{algo:bbfuzzing} selects one
input from the seeds corpus using the strategy of choice (\eg~stochastically, by
execution time, crash density). Next, the \texttt{MutateSeed} function applies a
mutation operator (\eg~bit-flips, insertion or deletion of words) to the
selected input to create a new one which is then fed to the \ac{SUT}. Different
mechanisms can then be deployed to identify whether the program crashed under
the given input, often program or \ac{OS} specific; if the \ac{SUT} exhibits a
fault, the test case is stored with useful information about the occurred fault
to later report about it to the tester.

Tools like zzuf or Radamsa only implement the \texttt{MutateSeed} function on
line~\ref{algo:bbfuzzing:ms}, leaving the remaining components' implementation
to the tester. For example zzuf applies random bit-flips to its input using a
set \emph{mutation ratio} (how much of the input to change) fully configurable
by the user within an interval or fixed. Radamsa performs instead a number of
more sophisticated mutation operators such as insert, repeat, drop and swap on
entities like bytes, ASCII and Unicode texts or arithmetic manipulations. More
complex black-box mutational fuzzers implement all components of
Algorithm~\ref{algo:bbfuzzing} and are able to exploit knowledge of the running
campaign to achieve better results.
The \textbf{\acf{BFF}}~\cite{householder2012probability} uses \emph{crash
density} as a metric to decide which pair of seed input and mutation ratio to
use for the next call to \texttt{MutateSeed} (\ac{BFF} uses indeed zzuff within
its mutation engine). Crash density of a seed is defined as the number of
crashes found by fuzzing that seed, divided by the number of total test cases
generated by the seed. Each execution of a mutated seed is modeled as a
Bernoulli trial where the outcome is whether or not the \ac{SUT} exhibited a
defect. The Binomial distribution that would result from successive trials is
approximated by a Poisson distribution as the number of trials is much higher
than the number of times a fault is found. The upper bound of the $95\%$
confidence interval of that distribution is then used to compute the probability
$p_i$ of selecting the seed file $t_i$. The same process is applied for a single
seed file and a fixed set of mutation ratio ranges so that for each seed file
there is a probability distribution over the set of ranges.
\citeauthor{woo2013scheduling} give the name \ac{FCS}~\cite{woo2013scheduling}
to describe the problem of selecting the next seed and mutation ratio pair to
fuzz (what they call a \emph{fuzzing configuration}) and recognize the
\ac{MAB}~\cite{berry1985bandit} nature of the problem. The authors take one step
further by modeling black-box mutational fuzzing as a weighted version of the
Coupon Collector's Problem and use those insights to inspect the \ac{FCS}
problem along three different axes that allows them to compose and evaluate a
total of 26 \ac{MAB} algorithms.

\section{Coverage-based Gray-box Fuzzing}
\label{sec:cgf}

A \ac{CGF} uses lightweight instrumentation and monitoring of the \ac{SUT} to
gain coverage information. This information is then exploited to provide a
solution to the \ac{FCS}
problem~\cite{afltech,lemieux2017fairfuzz,bohme2017directed,bohme2017coverage}.
The general approach is described in Algorithm~\ref{algo:cgf}.

\begin{algorithm}
    \DontPrintSemicolon%
    \SetKwFunction{SelectNext}{SelectNext}
    \SetKwFunction{AssignEnergy}{AssignEnergy}
    \SetKwFunction{MutateInput}{MutateInput}
    \SetKwFunction{IsInteresting}{IsInteresting}
    \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
    \Input{Set of seed inputs $S$}
    \Output{Set of crashing inputs $C$}
    \BlankLine%
    $C \leftarrow \emptyset$\;
    $Q \leftarrow S$\;
    \If{$Q = \emptyset$}{$Q \leftarrow \{\text{empty file}\}$}
    \Repeat{timeout reached or abort signal received}{%
        $t \leftarrow \SelectNext{Q}$\;\label{algo:cgf:sn}
        $p \leftarrow \AssignEnergy{t}$\;\label{algo:cgf:ae}
        \For{$i\in\left[0 \dots p\right]$}{%
            $t^\prime \leftarrow \MutateInput{t}$\;\label{algo:cgf:mi}
            \uIf{$t^\prime$ crashes}{%
                $C \leftarrow C \bigcup \left\{t^\prime\right\}$\;
            }
            \ElseIf{\IsInteresting{$t^\prime$}\label{algo:cgf:ii}}{%
                $Q \leftarrow Q \bigcup \left\{t^\prime\right\}$\;
            }
        }
    }
    \caption{Coverage-based Gray-box Fuzzing}
\label{algo:cgf}
\end{algorithm}

The first difference from black-box mutational fuzzing is that a \ac{CGF} does
not need a corpus of seed files to work properly (although it would be more
efficient). \citeauthor{afl}, the author of AFL, was able to generate valid JPEG
images starting from an empty file~\cite{afljpeg}. The functions
\texttt{SelectNext} and \texttt{MutateInput} (at lines~\ref{algo:cgf:sn}
and~\ref{algo:cgf:mi} respectively) are analogues of \texttt{SelectSeed} and
\texttt{MutateSeed} of Algorithm~\ref{algo:bbfuzzing}. The function
\texttt{AssignEnergy} at line~\ref{algo:cgf:ae} decides how much effort should
be put in fuzzing the selected test-case (\eg~how many mutated inputs should be
created from it). Another difference from black-box mutational fuzzers is the
\texttt{IsInteresting} function at line~\ref{algo:cgf:ii}, responsible to
determine whether the mutated input is deemed \emph{interesting} and worth
fuzzing; this allows for \acp{CGF} to build a corpus of test-cases that could
even be reused with other tools or to fuzz another software that accepts the
same file format. For \acp{CGF}, interesting, loosely means that increases code
coverage and by keeping a queue of test-cases with ever-increasing coverage
helps fuzzers of this kind reaching deeper portions of the \ac{SUT} compared to
black-box mutational fuzzers.

\paragraph{American Fuzzy Lop}
% - AFL-likes: AFL, AFLFast, FairFuzz

\paragraph{Honggfuzz}

\paragraph{VUzzer}

\section{Cooperative Fuzzing}
\label{sec:coop}
% TODO: using different fuzzers / methods together
% - driller & symfuzz
% - OSS-fuzz & clusterfuzz
% - Chemotactic

% TODO: brief of how we tackle the problem of using different fuzzers

