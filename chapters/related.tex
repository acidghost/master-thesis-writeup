\chapter{Related Work}
\label{chap:related}

In this chapter we are going to present the mechanics of some kind of fuzzers
and some specific implementations of \acfp{CGF}. Then we move on presenting
efforts of researchers trying to combine different fuzzing engines or testing
techniques with the aim of improving performance or efficiency.

\section{Black-box Mutational Fuzzing}
\label{sec:bbfuzz}
Black-box \emph{mutational} fuzzing (or \emph{Random Testing}) is a simple
testing technique that uses mutation operators on a sample input to produce a
new input; a corpus of \emph{valid} files (the more the better) is required to
achieve good efficiency by reducing the search space. A simple algorithmic
representation is given in Algorithm~\ref{algo:bbfuzzing}.

\begin{algorithm}
    \DontPrintSemicolon%
    \SetKwFunction{SelectSeed}{SelectSeed}
    \SetKwFunction{MutateSeed}{MutateSeed}
    \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
    \Input{Set of samples $S$}
    \Output{Set of crashing inputs $C$}
    \BlankLine%
    $C \leftarrow \emptyset$\;
    \While{stop condition is not met}{%
        $t \leftarrow \SelectSeed{S}$\;\nllabel{algo:bbfuzzing:ss}
        $t^\prime \leftarrow \MutateSeed{t}$\;\nllabel{algo:bbfuzzing:ms}
        \If{$t^\prime$ crashes program}{%
            $C \leftarrow C \bigcup \{t^\prime\}$\;
        }
    }
    \caption{Black-box mutational fuzzing}
\label{algo:bbfuzzing}
\end{algorithm}

The main algorithm works within a loop that stops at a predetermined condition
such as the end of a time budget, after the first crash has been found or after
a certain number of inputs have been tested, to name a few. More rudimentary
tools such as \textbf{zzuf}~\cite{hocevar2011zzuf} or
\textbf{Radamsa}~\cite{helin2015radamsa} allow for the tester to apply his or
her own stop criteria for the fuzzing campaign. The \texttt{SelectSeed} function
on line~\ref{algo:bbfuzzing:ss} of Algorithm~\ref{algo:bbfuzzing} selects one
input from the seeds corpus using the strategy of choice (\eg~stochastically, by
execution time, crash density). Next, the \texttt{MutateSeed} function applies a
mutation operator (\eg~bit-flips, insertion or deletion of words) to the
selected input to create a new one which is then fed to the \ac{SUT}. Different
mechanisms can then be deployed to identify whether the program crashed under
the given input, often program or \ac{OS} specific; if the \ac{SUT} exhibits a
fault, the test case is stored with useful information about the occurred fault
to later report about it to the tester.

Tools like zzuf or Radamsa only implement the \texttt{MutateSeed} function on
line~\ref{algo:bbfuzzing:ms}, leaving the remaining components' implementation
to the tester. For example zzuf applies random bit-flips to its input using a
set \emph{mutation ratio} (how much of the input to change) fully configurable
by the user within an interval or fixed. Radamsa performs instead a number of
more sophisticated mutation operators such as insert, repeat, drop and swap on
entities like bytes, ASCII and Unicode texts or arithmetic manipulations. More
complex black-box mutational fuzzers implement all components of
Algorithm~\ref{algo:bbfuzzing} and are able to exploit knowledge of the running
campaign to achieve better results.
The \textbf{\acf{BFF}}~\cite{householder2012probability} uses \emph{crash
density} as a metric to decide which pair of seed input and mutation ratio to
use for the next call to \texttt{MutateSeed} (\ac{BFF} uses indeed zzuff within
its mutation engine). Crash density of a seed is defined as the number of
crashes found by fuzzing that seed, divided by the number of total test cases
generated by the seed. Each execution of a mutated seed is modeled as a
Bernoulli trial where the outcome is whether or not the \ac{SUT} exhibited a
defect. The Binomial distribution that would result from successive trials is
approximated by a Poisson distribution as the number of trials is much higher
than the number of times a fault is found. The upper bound of the $95\%$
confidence interval of that distribution is then used to compute the probability
$p_i$ of selecting the seed file $t_i$. The same process is applied for a single
seed file and a fixed set of mutation ratio ranges so that for each seed file
there is a probability distribution over the set of ranges.
\citeauthor{woo2013scheduling} give the name \ac{FCS}~\cite{woo2013scheduling}
to describe the problem of selecting the next seed and mutation ratio pair to
fuzz (what they call a \emph{fuzzing configuration}) and recognize the
\ac{MAB}~\cite{berry1985bandit} nature of the problem. The authors take one step
further by modeling black-box mutational fuzzing as a weighted version of the
Coupon Collector's Problem and use those insights to inspect the \ac{FCS}
problem along three different axes that allows them to compose and evaluate a
total of 26 \ac{MAB} algorithms.

\section{Coverage-based Gray-box Fuzzing}
\label{sec:cgf}

A \ac{CGF} uses lightweight instrumentation and monitoring of the \ac{SUT} to
gain coverage information. This information is then exploited to provide a
solution to the \ac{FCS}
problem~\cite{afltech,lemieux2017fairfuzz,bohme2017directed,bohme2017coverage}.
The general approach is described in Algorithm~\ref{algo:cgf}.

\begin{algorithm}
    \DontPrintSemicolon%
    \SetKwFunction{SelectNext}{SelectNext}
    \SetKwFunction{AssignEnergy}{AssignEnergy}
    \SetKwFunction{MutateInput}{MutateInput}
    \SetKwFunction{IsInteresting}{IsInteresting}
    \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
    \Input{Set of seed inputs $S$}
    \Output{Set of crashing inputs $C$}
    \BlankLine%
    $C \leftarrow \emptyset$\;
    $Q \leftarrow S$\;
    \If{$Q = \emptyset$}{$Q \leftarrow \{\text{empty file}\}$}
    \Repeat{timeout reached or abort signal received}{%
        $t \leftarrow \SelectNext{Q}$\;\label{algo:cgf:sn}
        $p \leftarrow \AssignEnergy{t}$\;\label{algo:cgf:ae}
        \For{$i\in\left[0 \dots p\right]$}{%
            $t^\prime \leftarrow \MutateInput{t}$\;\label{algo:cgf:mi}
            \uIf{$t^\prime$ crashes}{%
                $C \leftarrow C \bigcup \left\{t^\prime\right\}$\;
            }
            \ElseIf{\IsInteresting{$t^\prime$}\label{algo:cgf:ii}}{%
                $Q \leftarrow Q \bigcup \left\{t^\prime\right\}$\;
            }
        }
    }
    \caption{Coverage-based Gray-box Fuzzing}
\label{algo:cgf}
\end{algorithm}

The first difference from black-box mutational fuzzing is that a \ac{CGF} does
not need a corpus of seed files to work properly (although it would be more
efficient). \citeauthor{afl}, the author of AFL, was able to generate valid JPEG
images starting from an empty file~\cite{afljpeg}. The functions
\texttt{SelectNext} and \texttt{MutateInput} (at lines~\ref{algo:cgf:sn}
and~\ref{algo:cgf:mi} respectively) are analogues of \texttt{SelectSeed} and
\texttt{MutateSeed} of Algorithm~\ref{algo:bbfuzzing}. The framework of
Algorithm~\ref{algo:cgf} incorporates explicitly the mechanics that \emph{smart}
black-box mutational fuzzers like \ac{BFF} implement. The function
\texttt{AssignEnergy} at line~\ref{algo:cgf:ae} decides how much effort should
be put in fuzzing the selected test-case (\eg~how many mutated inputs should be
created from it). Another difference from black-box mutational fuzzers is the
\texttt{IsInteresting} function at line~\ref{algo:cgf:ii}, responsible to
determine whether the mutated input is deemed \emph{interesting} and worth
fuzzing; this allows for \acp{CGF} to build a corpus of test-cases that could
even be reused with other tools or to fuzz another software that accepts the
same file format. For \acp{CGF}, interesting, loosely means that increases code
coverage and by keeping a queue of test-cases with ever-increasing coverage
helps fuzzers of this kind reaching deeper portions of the \ac{SUT} compared to
black-box mutational fuzzers.

\subsection{American Fuzzy Lop}
% - AFL-likes: AFL, AFLFast, FairFuzz
AFL~\cite{afl} is one of the most well known \acp{CGF}. Its focus is not on any
singular principle or insights but is rather a collection of hacks that have
been tested and proved effective in practice; the governing principles for its
development are speed, reliability and ease of use~\cite{afltech}. AFL gets its
coverage feedback from the \ac{SUT} by instrumenting its compiled binary. This
is done by injecting specific locations of the \ac{SUT} with a monitoring
snippet of code. This code can be injected by compiling the \ac{SUT} with the
\texttt{afl-gcc} utility or, when the source code is not available, AFL uses
QEMU~\cite{bellard2005qemu} to dynamically (during interpretation, at runtime)
instrument the binary. AFL-dyninst~\cite{afldyn} is an extension to AFL that
injects the instrumentation snippet directly into the binary. What AFL injects
into the \ac{SUT} is essentially equivalent to that presented in
Listing~\ref{lst:aflbininst}.

\begin{lstlisting}[caption={AFL's instrumentation},label=lst:aflbininst,float]
    cur_location = <COMPILE_TIME_RANDOM>;
    shared_mem[cur_location ^ prev_location]++;
    prev_location = cur_location >> 1;
\end{lstlisting}

The instrumentation snippet is injected at every branch within the instrumented
code. The \texttt{cur\_location} variable is generated randomly at compile time
and identifies the current \emph{basic block} (a straight code sequence without
branches besides at its entry and exit points). The \texttt{shared\_mem} array
is a 64KB shared memory region provided by the fuzzer; each byte of the shared
memory can be thought of as a hit to a transition from one branch to another.
The shift operation at the last line preserves directionality of the tuples
(\eg~$A \oplus B$ would be indistinguishable from $B \oplus A$) and to keep the
identity of loops within the same basic block (\eg~$A \oplus A$ would be equal
to $B \oplus B$).

With regards to Algorithm~\ref{algo:cgf}, AFL implements the \texttt{SelectNext}
function by classifying elements of the queue as \emph{favorites}. A test-case
is deemed favorite if it exhibits faster speed of execution and small size for
the branch tuples that it covers compared to the other test-cases in the queue.
AFL selects favorite items more often, implementing a strategy that favors,
using the \ac{MAB} terminology, exploitation against exploration
\cite{bohme2017coverage}. AFL applies a set of deterministic mutation operators
to new inputs that come into the queue and later uses what it calls an
\emph{havoc stage} where mutations are stochastically applied; the function
\texttt{AssignEnergy} determines how many mutations should be applied to the
selected test-case during the havoc stage. AFL's implementation of
\texttt{AssignEnergy} uses a mix of execution speed, coverage information and
age of the selected test-case to determine how many inputs should be generated
by mutating it. AFL implements a good number of mutation operators such as
bit-flips, insertion and deletion of bytes, arithmetic operators, to name a few
\cite{aflmut}. The function \texttt{IsInteresting} as implemented by AFL,
returns true if the input $t^\prime$ exercises a new basic block transition or
if the number of times a transition is hit goes from one range of values to the
next; AFL employs a ``bucketing'' scheme where the range of values required to
be in the next bucket roughly doubles (the exact values are $1$, $2$, $3$,
$4-7$, $8-15$, $16-31$, $32-127$ and $128+$)~\cite{afltech}.

\paragraph{AFLFast}
By observing that an high proportion of test-cases generated by AFL exercise a
small number of \emph{high frequency paths}, \citeauthor{bohme2017coverage} draw
the intuition that steering fuzzing more toward \emph{low frequency paths} could
lead to an improvement in performance (exploring more paths with the same amount
of fuzz). AFLFast~\cite{bohme2017coverage} is an extension to AFL that
implements two search strategies within the \texttt{SelectNext} function and a
number of power schedules within \texttt{AssignEnergy}. To derive more
meaningful insights, the authors model Coverage-based Gray-box Fuzzing as a
Markov Chain and use their results to dissect problems of \acp{CGF} and derive
meaningful power schedules (exploitation-based constant schedule\footnote{The
same used by AFL}, exploration-based constant schedule, cut-off exponential,
exponential, linear and quadratic). Their evaluation of AFLFast over common UNIX
utilities shows that the exponential schedule works best and provide promising
results when compared to AFL\@. When both AFL and AFLFast are able to discover
(within the given time budget) the same vulnerability, AFLFast does it much
quicker.
% maybe expand on the CGFuzzing as a Markov Chain?

\paragraph{FairFuzz}

\subsection{Honggfuzz}

\subsection{VUzzer}

\section{Cooperative Fuzzing}
\label{sec:coop}
% TODO: using different fuzzers / methods together
% - driller & symfuzz
% - OSS-fuzz & clusterfuzz
% - Chemotactic

% TODO: brief of how we tackle the problem of using different fuzzers

