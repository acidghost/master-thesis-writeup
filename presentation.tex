\documentclass[handout]{beamer}

\mode<presentation>
\usetheme{CambridgeUS}
\usecolortheme{seahorse}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage[noend]{algorithm2e}
\usepackage{graphicx}

\include{macros}

\title{\myTitle}
\subtitle{\mySubtitle}
\author{\myName}
\institute[VU]{\myUni}

% \AtBeginSection[]
% {%
%     \begin{frame}
%         \tableofcontents[currentsection,subsectionstyle=shaded]
%     \end{frame}
% }

\AtBeginSubsection[]
{%
    \begin{frame}
        \tableofcontents[currentsection,currentsubsection]
    \end{frame}
}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
    \tableofcontents[pausesections]
\end{frame}

\section{Background and Related Work}

\subsection*{Software Testing}

% software quality
\begin{frame}<presentation:0>[noframenumbering]{Quality in Software Products}
    \uncover<+->{Producing \alert{high-quality} software is more and more a
    necessity}
    \begin{itemize}[<+->]
        \item{} banking systems
        \item{} aerospace applications
        \item{} ubiquitous and pervasive computing
        \item{} and many more to come\ldots\
    \end{itemize}
\end{frame}

\begin{frame}<presentation:0>[noframenumbering]{Quality in Software Products}
    \uncover<+->{Quality is conformance to \alert{requirements}}
    \begin{itemize}[<+->]
        \item{} determined by customer's needs
        \item{} belong to different quality parameters\\
            (\eg~functionality, usability, reliability, performance, security)
    \end{itemize}
\end{frame}

% during development or after
\begin{frame}<presentation:0>[noframenumbering]{Developing with Quality}
    \structure<+->{The best way to produce quality software is to put it there in
        the first place}
    \\~\\
    \uncover<+->{Software engineers have different tools at their disposal:}
    \begin{itemize}[<+->]
        \item{} defensive programming;
        \item{} code reviews;
        \item{} advanced programming languages;
        \item{} formal methods.
    \end{itemize}~\\
    \uncover<+->{%
        \structure{\ldots~static methods need to be complemented by dynamic ones}
    }
\end{frame}

% define software testing (w/ examples)
\begin{frame}<presentation:0>[noframenumbering]{Software Testing}
    \begin{block}<+->{Definition of software testing from the SWEBOK Guide}
        \begin{quote}
            Software testing consists of the \alert{dynamic} verification that a
            program provides \alert{expected} behaviours on a \alert{finite} set
            of test cases, suitably \alert{selected} from the usually infinite
            execution domain.
        \end{quote}
    \end{block}
\end{frame}

\begin{frame}<presentation:0>[noframenumbering]{Software Testing Techniques}
    \begin{block}<+->{Commonly categorized by the knowledge they exploit}
        \begin{itemize}[<+->]
            \item{} black box: only functional specification;
            \item{} white box: also knowledge about internal structure;
            \item{} gray box: partial or inferred knowledge of internal structure.
        \end{itemize}
    \end{block}
    \begin{exampleblock}<+->{Examples}
        \begin{itemize}[<+->]
            \item{} pairwise testing
            \item{} equivalence-class partitioning
            \item{} boundary-value analysis
            \item{} symbolic execution
            \item{} random testing (\ie~\alert{fuzzing})
        \end{itemize}
    \end{exampleblock}
\end{frame}

\subsection{Fuzzing Techniques}

% fuzz testing
\begin{frame}{Fuzzing}
    \begin{itemize}[<+->]
        \item{} term coined in 1988 during a quiet and stormy night\ldots\
        \item{} ``Mayhem'' wins 2016 DARPA Cyber Grand Challenge
        \item{} used in industry by Microsoft and Google
        \item{} particularly suited to reliability and security testing
    \end{itemize}
\end{frame}

\begin{frame}{Black Box Mutational Fuzzing}
    \begin{block}<+->{General operation}
        \setbeamercovered{transparent}
        \begin{enumerate}[<+->]
            \item{} select an input from a seed corpus
            \item{} mutate the input to produce a new one
            \item{} execute the program with the mutated input
            \item{} monitor for unexpected behaviours
        \end{enumerate}
    \end{block}
    \begin{exampleblock}<+->{Examples}
        Radamsa, zzuf, Basic Fuzzing Framework
    \end{exampleblock}
\end{frame}

\begin{frame}{Coverage-Based Gray Box Fuzzing}
    \begin{itemize}[<+->]
        \item{} execution is monitored to gain feedback
        \item{} the feedback is used to better instruct the search
        \item{} maintains a set of inputs
        \item{} at each iteration:
            \begin{enumerate}
                \item<.-> choose element from the set
                \item{} choose how many inputs to generate
                \item{} adds inputs to the set if increase coverage
            \end{enumerate}
    \end{itemize}
\end{frame}

\begin{frame}{American Fuzzy Lop}
    \begin{itemize}[<+->]
        \item{} one of the most popular coverage-based fuzzers
        \item{} instruments the SUT to obtain coverage feedback
        \item{} selects favorite inputs more often
        \item{} mutation as deterministic and havoc stages
        \item{} stores generated input if branch hit counts change bucket
    \end{itemize}
\end{frame}

\begin{frame}{Extensions to AFL}
    \begin{block}<+->{AFLFast}
        \begin{itemize}[<+->]
            \item{} models fuzzing as a Markov chain
            \item{} focus fuzzing on low frequency paths
            \item{} modifies search strategy
                \note{mixture of least selected and then low frequency
                (path exercised by the least inputs)}
            \item{} modifies power schedules
        \end{itemize}
    \end{block}
    \begin{block}<+->{FairFuzz}
        \begin{itemize}[<+->]
            \item{} focus fuzzing on rare branches
            \item{} search strategy prioritizes inputs that hit a rare branch
            \item{} mutation preserves parts necessary to hit rare branch
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Other Gray Box Fuzzers}
    \begin{block}<+->{Honggfuzz}
        \begin{itemize}[<+->]
            \item{} provides great throughput compared to AFL
            \item{} simplifies operation:
                \begin{itemize}
                    \item<.-> selects at random
                    \item{} mutates only once
                \end{itemize}
            \item{} uses hardware sources for coverage
        \end{itemize}
    \end{block}
    \begin{block}<+->{VUzzer}
        \begin{itemize}[<+->]
            \item{} employs a population-based model (\ie~Evolutionary Algorithms)
            \item{} fitness function uses branch hit frequencies
            \item{} application-aware recombination and mutation operators
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Symbolic-Assisted White Box Fuzzing}
    \begin{block}<+->{Key features}
        \begin{itemize}[<+->]
            \item{} uses symbolic execution to collect path constraints
            \item{} constraints are solved to provide new inputs
            \item<+-|alert@+-> \alert{constraints not always solvable or solver is slow}
        \end{itemize}
    \end{block}
    \begin{exampleblock}<+->{Examples}
        \begin{itemize}[<+->]
            \item{} DART and SAGE
            \item{} EXE and KLEE
            \item{} Mayhem
        \end{itemize}
    \end{exampleblock}
\end{frame}

\subsection{Hybrid and Cooperative Fuzzing}

\begin{frame}{Hybrid Approaches}
    \structure<+->{Merge white box fuzzers with black or gray box ones}
    \\~\\
    \begin{exampleblock}<+->{Driller}
        \begin{itemize}
            \item{} uses AFL and custom symbolic execution engine
            \item{} AFL becomes ``stuck'' $\rightarrow$ s.e.\ generates new inputs
        \end{itemize}
    \end{exampleblock}
\end{frame}

\begin{frame}{Cooperative Fuzzing}
    \begin{block}<+->{A system that allows fuzzers to share information to achieve a common goal}
        \begin{itemize}[<+->]
            \item{} fuzzing is non-deterministic
            \item{} there is no best fuzzer for all possible programs
            \item{} information sharing as a mean to share features
                \note{example: VUzzer may share input with magic bytes to AFL}
        \end{itemize}
    \end{block}
    \begin{exampleblock}<+->{Examples}
        \begin{itemize}
            \item{} Levy Flights over an input space
            \item{} Chemotactic test case recombination
        \end{itemize}
    \end{exampleblock}
\end{frame}

\section{Cooperative Fuzzing Framework}

\subsection{System Design}

\begin{frame}{Common Fuzzer Interface}
    \begin{block}{Three API primitives}
        \begin{itemize}[<+->]
            \item{} \alert{extract} test cases from fuzzer
            \item{} \alert{inject} test cases into fuzzer
            \item{} \alert{congestion control} for slower or generational
                fuzzers
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Central Decisional Unit}
    \begin{columns}
        \begin{column}{.5\textwidth}
            \begin{figure}
                \includegraphics[width=.5\textwidth]{figures/dia/system_design_logical}
                \caption{Logical view}
            \end{figure}
            \begin{figure}
                \includegraphics[width=.5\textwidth]{figures/dia/system_design_physical}
                \caption{Physical view}
            \end{figure}
        \end{column}
        \begin{column}{.5\textwidth}
            \begin{itemize}
                \item{} acts as intermediary for information exchange
                \item{} uses API to implement a strategy
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Cooperative Fuzzing Strategies}
\scalebox{.8}{%
    \begin{algorithm}[H]
        \DontPrintSemicolon%
        \SetKwFunction{Score}{Score}
        \SetKwFunction{Winning}{Winning}
        \SetKwFunction{Inject}{Inject}
        \SetKwFunction{WinningC}{WinningCongestion}
        % \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
        % \Input{Set of running fuzzers $F$. Set of fuzzers that need congestion control $F_c$}
        % \BlankLine%
        \ForEach{$f \in F_c$}{%
            $W_f \leftarrow \emptyset$\;
        }
        \While{all fuzzers are running}{%
            \If{new test-case $t$ from a fuzzer $f_t$}{%
                $S \leftarrow \emptyset$\;
                \ForEach{$f \in F \setminus \{f_t\}$}{%
                    $s \leftarrow \Score{f, t}$\;
                    \uIf{$f \in F_c$}{%
                        $W_f \leftarrow W_f \cup \{(t, s)\}$\;
                    }
                    \Else{%
                        $S \leftarrow S \cup \{(f, s)\}$\;
                    }
                }
                \ForEach{$f \in \Winning{S}$}{%
                    \Inject{f, t}\;
                }
            }
            \ForEach{$f \in F_c$}{%
                \If{$f$ is ready to receive inputs}{%
                    \ForEach{$t \in \WinningC{$W_f$}$}{%
                        \Inject{f, t}\;
                    }
                    $W_f \leftarrow \emptyset$\;
                }
            }
        }
    \end{algorithm}
}
\end{frame}

\subsection{System Implementation}

\section{Evaluation}

\subsection{Single Fuzzers Evaluation}

\subsection{Cooperative Fuzzing Evaluation}

\subsection{Crash Analysis and Known Vulnerabilities}

\section{Discussion and Future Work}

\subsection*{Discussion}

\subsection*{Future Work}

\end{document}
